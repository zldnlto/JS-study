# 전역 변수의 문제점
##### 무분별한 사용 지양하기  

## 변수의 생명 주기

변수의 생명 주기가 없다면 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다. 

### 전역 변수의 생명 주기 = 전역 객체의 생명 주기
- 전역 객체: 코드가 실행되기 이전에 js엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체 
- 브라우저: window, 서버사이드 (node.js): global
- 즉 브라우저를 닫을 때까지 변수가 유효하게 된다. 

전역 변수 선언은 런타임 이전 단계에서 자바스크립트 엔진에 의해 먼저 실행 

변수의 생명 주기는 메모리 공간이 확보된 시점 ~ 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지  

누군가가 스코프를 참조하고 있으면 소멸하지 않고 생존한다. 


### 전역 변수의 문제점
- 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것   
변수의 유효 범위가 클 수록 코드의 가독성이 나빠지고 의도와는 다르게 작성될 수 있다.  
- 긴 생명 주기 - 메모리 리소스 소비 
- 스코프 체인 상에서 종점에 존재하므로 전역 변수의 검색 속도가 가장 느리다 
- 네임스페이스 오염 

### 전역 변수의 사용 억제하는 방법 
#### 변수의 스코프는 좁을수록 좋다

1. 즉시 실행 함수 : 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.
``` js
(function () {
    let foo = 10;
}());
console.log(foo) // ReferenceError : not defined
```

2. 네임 스페이스 객체 : 네임 스페이스 역할의 객체를 생성하고 전역 변수처럼 사용할 변수를 프로퍼티로 추가한다. 
```js
let MYAPP = {}; //전역 네임스페이스 객체
MYAPP.person = { //계층적 구성 가능
    name:'Lee',
    address:'Seoul',
}
console.log(MYAPP.person.name); // Lee
```

3. 모듈 패턴 : 관련 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈로 만들기 (클래스 모방) - 클로저 기반으로 동작 
- 전역 변수 억제 + 캡슐화
- 캡슐화 : 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것 

```js
let Counter = (function () {
    //private 변수
    let num = 0;
    //외부로 공개할 데이터, 메서드를 프로퍼티로 추가한 객체들 반환
    return {
        increase() {
            return ++num;
        },
        decrease() {
            return --num;
        }
    };
}())
```
```js
console.log(Counter.num); // undefined
console.log(Counter.increase()); //1
console.log(Counter.increase()); //2
console.log(Counter.decrease()); //1 
```
====
  

:pushpin: 유념할 keyword : 호이스팅, 캡슐화 

:pencil2: 24. 클로저 

- - - 

